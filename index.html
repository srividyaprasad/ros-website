<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Easy Robotics with ROS</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Easy Robotics with ROS</h1>
        <nav>
            <ul>
                <li><a href="#ubuntu">Why Ubuntu?</a></li>
                <li><a href="#ros-versions">ROS Versions</a></li>
                <li><a href="#setup">Setup Guide</a></li>
                <li><a href="#tools">Best Tools</a></li>
                <li><a href="#docker">ROS with Docker</a></li>
                <li><a href="#basic-concepts">Basic ROS Concepts</a></li>
                <li><a href="#workspaces">ROS Workspaces</a></li>
                <li><a href="#urdf">URDF & Robot Modeling</a></li>
                <li><a href="#tf">TF & Transformations</a></li>
                <li><a href="#navigation">ROS Navigation Basics</a></li>
                <li><a href="#hardware">ROS Hardware Integration</a></li>
                <li><a href="#custom-messages">Custom ROS Messages & Services</a></li>
            </ul>
        </nav>
    </header>
    
    <section id="ubuntu">
        <h2>Why Ubuntu for ROS?</h2>
        <p>Ubuntu is the preferred OS for ROS development due to its stability, long-term support (LTS) releases, and extensive package support. ROS is officially supported on Ubuntu, ensuring better compatibility and community assistance. Ubuntu is Linux based and since Linux is open-source a lot of the embedded operating sysems are also Linux-based making it easier to maintain ROS versions for the maximum number of applications and platforms.</p>
    </section>
    
    <section id="ros-versions">
        <h2>ROS Versions & Ubuntu Compatibility</h2>
        <p>Each ROS version is designed to work best with specific Ubuntu distributions:</p>
        <ul>
            <li><strong>ROS Noetic</strong> (Ubuntu 20.04 LTS)</li>
            <li><strong>ROS2 Humble</strong> (Ubuntu 22.04 LTS)</li>
            <li><strong>ROS2 Galactic</strong> (Ubuntu 20.04 LTS)</li>
        </ul>
    </section>
    
    <section id="setup">
        <h2>Setting Up Ubuntu for ROS</h2>
        <p>Follow these steps to install ROS on Ubuntu:</p>
        <pre>
        sudo apt update && sudo apt upgrade -y
        sudo apt install ros-noetic-desktop-full
        </pre>
    </section>
    
    <section id="tools">
        <h2>Best Development Tools for ROS</h2>
        <ul>
            <li><strong>RViz</strong> - Best for visualization</li>
            <li><strong>Gazebo</strong> - High-fidelity simulation</li>
            <li><strong>Docker</strong> - Run ROS without installation hassles</li>
            <li><strong>VS Code</strong> - Great for ROS development</li>
        </ul>
    </section>
    
    <section id="docker">
        <h2>ROS with Docker - The Easy Way üöÄ</h2>
        <p>Welcome to the easiest way to run ROS! No more installation nightmares‚Äîjust use <strong>Docker</strong> and get started with ROS right away. This guide will help you set up <strong>ROS Noetic</strong> (for ROS1) and <strong>ROS2 Humble</strong> in Docker and provide tutorials on <strong>Turtlesim</strong> and <strong>TurtleBot3</strong> simulation.</p>
        
        <h3>üöÄ Quick Start</h3>
        <h4>Prerequisites</h4>
        <ul>
            <li>Install <strong>Docker</strong> (<a href="https://docs.docker.com/get-docker/">Docker Installation</a>)</li>
            <li>Install <strong>Docker Compose</strong> (<a href="https://docs.docker.com/compose/install/">Docker Compose Installation</a>)</li>
        </ul>

        <h4>Clone this Repository</h4>
        <pre>
git clone https://github.com/your-username/ros-docker-tutorial.git
cd ros-docker-tutorial
        </pre>
        
        <h4>Build and Run ROS1 Docker</h4>
        <pre>
docker-compose up -d ros1
        </pre>
        
        <h4>Build and Run ROS2 Docker</h4>
        <pre>
docker-compose up -d ros2
        </pre>
        
        <h4>Enter the container</h4>
        <pre>
docker exec -it ros-container-name bash
        </pre>

        <h3>üìå ROS1: Turtlesim Tutorial üê¢</h3>
        <pre>
roscore &
rosrun turtlesim turtlesim_node
rosrun turtlesim turtle_teleop_key
        </pre>
        <p>More details: <a href="http://wiki.ros.org/turtlesim">ROS1 Turtlesim Documentation</a></p>

        <h3>ü§ñ ROS2: TurtleBot3 Simulation üèéÔ∏è</h3>
        <pre>
export TURTLEBOT3_MODEL=burger
source /opt/ros/humble/setup.bash
ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py
ros2 run turtlebot3_teleop teleop_keyboard
        </pre>
        <p>More details: <a href="https://emanual.robotis.com/docs/en/platform/turtlebot3/overview/">TurtleBot3 Documentation</a></p>
    
        <h3>üèûÔ∏è Best Visualization & Simulation Tools for ROS</h3>
        <h4>Using RViz</h4>
        <pre>
rosrun rviz rviz
ros2 run rviz2 rviz2
        </pre>
        <h4>Using Gazebo</h4>
        <pre>
roslaunch gazebo_ros empty_world.launch
ros2 launch gazebo_ros gazebo.launch.py
        </pre>
        
        <h3>üîÑ Switching Between OpenCV Versions</h3>
        <pre>
python3 -c "import cv2; print(cv2.__version__)"
pip install --upgrade opencv-python==4.5.5.62
python3 -c "import cv2; print(cv2.__version__)"
        </pre>
        
        <h3>üõ†Ô∏è Troubleshooting</h3>
        <ul>
            <li><strong>Cannot run GUI apps?</strong> Use <code>xhost +local:docker</code> and add <code>-e DISPLAY=$DISPLAY</code> to the Docker run command.</li>
            <li><strong>Container not found?</strong> Check running containers with <code>docker ps -a</code>.</li>
            <li><strong>ROS2 command not found?</strong> Ensure you sourced the workspace.</li>
            <li><strong>OpenCV version mismatch?</strong> Use <code>pip uninstall opencv-python</code> before installing a new version.</li>
        </ul>
    </section>
    
    <section id="basic-concepts">
        <h2>Basic ROS Concepts</h2>
        <p>Understanding ROS nodes, topics, services, and actions is essential. Here‚Äôs a basic example of a ROS publisher and subscriber:</p>
        <pre>
        rostopic pub /chatter std_msgs/String "Hello, ROS!"
        rostopic echo /chatter
        </pre>
    </section>
    
    <section id="workspaces">
        <h2>ROS Workspaces & Catkin/Colcon</h2>
        <p>ROS uses workspaces to organize projects. Set up a Catkin workspace:</p>
        <pre>
        mkdir -p ~/catkin_ws/src
        cd ~/catkin_ws
        catkin_make
        </pre>
    </section>
    
    <section id="urdf">
        <h2>URDF & Robot Modeling</h2>
        <p>URDF (Unified Robot Description Format) is used to model robots. Example URDF snippet:</p>
        <pre>
        <robot name="my_robot">
            <link name="base_link"/>
        </robot>
        </pre>
    </section>
    
    <section id="tf">
        <h2>TF & Transformations</h2>
        <p>TF is used to manage coordinate transformations in ROS. A simple broadcaster example:</p>
        <pre>
        rosrun tf static_transform_publisher 0 0 0 0 0 0 base_link world 10
        </pre>
    </section>
    
    <section id="navigation">
        <h2>ROS Navigation Basics</h2>
        <p>The navigation stack allows autonomous robot movement. Example launch:</p>
        <pre>
        roslaunch turtlebot3_navigation turtlebot3_navigation.launch
        </pre>
    </section>
    
    <section id="hardware">
        <h2>ROS Hardware Integration</h2>
        <p>Integrate ROS with hardware like Arduino. Example setup:</p>
        <pre>
        rosrun rosserial_python serial_node.py /dev/ttyUSB0
        </pre>
    </section>
    
    <section id="custom-messages">
        <h2>Custom ROS Messages & Services</h2>
        <p>Creating a custom message:</p>
        <pre>
        echo "float32 x" > my_package/msg/Custom.msg
        </pre>
    </section>
    
    <section id="introduction">
        <h2>What is ROS?</h2>
        <p>
          ROS (Robot Operating System) is not a traditional operating system but a middleware framework that helps you build robot applications by connecting various components ‚Äì much like how different courses (algorithms, circuits, control theory) come together in your engineering syllabus.
        </p>
      </section>
    
      <!-- Core Concepts Parallels -->
      <section id="core-concepts">
        <h2>Core Concepts & Degree Parallels</h2>
        <ul>
          <li>
            <strong>Nodes & Topics:</strong>
            <p>
              In your computer science courses, you learn about network protocols and message passing (think of TCP/IP or MQTT). In ROS, <em>nodes</em> (independent processes) communicate via <em>topics</em> (named channels), similar to how network packets are routed between devices.
            </p>
          </li>
          <li>
            <strong>Messages & Services:</strong>
            <p>
              Just like in electrical engineering where you study signal processing and data transmission, ROS messages are structured packets carrying sensor data or commands. ROS <em>services</em> offer a request-response mechanism similar to how client-server models (like HTTP or RPC) work.
            </p>
          </li>
          <li>
            <strong>TF (Transform Frames):</strong>
            <p>
              In mechanical engineering, you study kinematics and coordinate transformations. TF in ROS keeps track of various coordinate frames (like the robot‚Äôs base, arm, or camera) ‚Äì much like how you learn to calculate positions and orientations in robotics classes.
            </p>
          </li>
          <li>
            <strong>Launch Files:</strong>
            <p>
              Similar to running shell scripts or using build automation tools in your software engineering labs, ROS launch files let you start and configure multiple nodes at once, streamlining the initialization of complex robotic systems.
            </p>
          </li>
          <li>
            <strong>Sensors & Actuators:</strong>
            <p>
              In courses on electrical circuits and control systems, you learn how sensors gather data and actuators convert electrical signals into physical movement. In robotics, sensors (cameras, LiDAR, IMUs) and actuators (motors, servos) work together to perceive and interact with the environment.
            </p>
          </li>
        </ul>
      </section>
    
      <!-- Detailed Syllabus-style Explanation -->
      <section id="syllabus-explanation">
        <h2>Deep Dive: ROS Concepts Through Your Degree Syllabus</h2>
        <h3>1. Computer Science Foundations</h3>
        <p>
          In your CS courses, you learn about data structures, algorithms, and networking. Similarly, ROS‚Äôs pub-sub model (nodes and topics) uses a modular approach that allows different programs to exchange information without needing a central hub ‚Äì a concept that mirrors distributed systems and middleware in software engineering.
        </p>
        
        <h3>2. Electrical Engineering & Signal Processing</h3>
        <p>
          EE courses introduce you to signal transmission and processing. ROS messages are akin to electrical signals that carry information. Services in ROS, which use a request-response model, are like communication protocols in embedded systems, ensuring that data (e.g., battery status or sensor readings) is reliably exchanged between hardware components.
        </p>
        
        <h3>3. Mechanical Engineering & Kinematics</h3>
        <p>
          Mechanical classes focus on the movement of parts and coordinate transformations. The TF library in ROS deals with similar challenges: tracking the positions of various parts of the robot in real-time, much like solving problems in forward and inverse kinematics.
        </p>
        
        <h3>4. Systems & Control Theory</h3>
        <p>
          Control theory is essential for managing feedback loops in robotics. Just as you study PID controllers and system dynamics in your control systems course, ROS integrates sensor feedback with actuator commands to maintain smooth and stable robot operation. Launch files and parameter servers function as configuration and control management tools that streamline system-wide settings.
        </p>
        
        <h3>5. Integration & Practical Labs</h3>
        <p>
          In your lab sessions, you work with hardware, microcontrollers (like Arduino or Raspberry Pi), and simulation tools. ROS connects seamlessly with simulation environments (e.g., Gazebo) and real hardware through drivers, much like lab projects where you build circuits and program microcontrollers to see theory in action.
        </p>
      </section>
    
      <!-- Advanced Topics -->
      <section id="advanced-topics">
        <h2>Advanced Topics & Industry Relevance</h2>
        <p>
          As you progress in your degree, you might take electives in robotics, AI, and embedded systems. Advanced ROS topics include integrating machine learning for perception and decision-making, real-time processing for autonomous navigation, and interfacing with modern sensors and actuators. These topics reflect current research trends and industrial needs, preparing you for a future where multidisciplinary robotics skills are in high demand.
        </p>
      </section>
    
      <!-- Conclusion -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          ROS serves as a bridge between the theoretical knowledge gained in your engineering courses and the practical world of robotics. By drawing parallels to your syllabus‚Äîfrom CS network protocols and EE signal processing to mechanical kinematics and control theory‚ÄîROS and robotics become much more approachable and relatable. Whether you‚Äôre working on an academic project or an industrial application, understanding these fundamentals will help you design, build, and control robots more effectively.
        </p>
        <p>
          Start exploring ROS today, and see how the concepts you‚Äôve learned in your courses come alive in the exciting field of robotics!
        </p>
      </section>

      <section id="some order in the chaos">
        <h2>Some Order in the Chaos</h2>
        <p>
          Sharing with you the order in which you can start learning tools and concepts required or suggested for mastering robotics from scratch.
        </p>
      </section>
    
    <footer>
        <p>¬© 2025 Easy Robotics with ROS | <a href="#">Contact Us</a></p>
    </footer>
</body>
</html>
